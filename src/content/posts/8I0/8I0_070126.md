---
title: 8I0 - 07-01-2026
published: 2026-01-07
description: Hướng dẫn giải bài tập cho 8I0 - 07-01-2026
tags: [Editorial]
category: 8I0
draft: false
---

# **Bài 1: Số nguyên tố đối xứng**

Với giới hạn của đề bài, ta có thể sàng nguyên tố tới $$10^7$$ và xử lý số nguyên tố cho từng truy vấn

<details>
<summary>Code mẫu</summary>

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
vector<bool> prime;

void sang(int limit) {
    prime.assign(limit + 1, true);
    prime[0] = prime[1] = false;
    for (int i = 2; i * i <= limit; i++) {
        if (prime[i]) {
            for (int j = i * i; j <= limit; j += i) prime[j] = false;
        }
    }
}

int flip(int x) {
    int res = 0;
    while (x > 0) {
        res = res * 10 + x % 10;
        x /= 10;
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    const int LIM = 1e7; 
    sang(LIM);

    for (int i = 2; i <= n; i++) {
        if (prime[i]) {
            int rev = flip(i);
            if (rev <= LIM && prime[rev]) cout << i << " ";
        }
    }
}

```
</details>

# **Bài 2: Tổng ước**

<details>
<summary>Code mẫu</summary>

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int T;
    cin >> T;
    vector<int> L; L.reserve(T);
    vector<int> R; R.reserve(T);
    int maxR = 0;
    for(int i = 0; i < T; ++i){
        int a, b;
        cin >> a >> b;
        if(a > b) swap(a, b);
        if(a < 1) a = 1;
        L.push_back(a);
        R.push_back(b);
        if(b > maxR) maxR = b;
    }

    int N = maxR;
    vector<int> d(N+1);
    vector<int> s(N+1);
    for(int i = 1; i <= N; ++i){
        for(int j = i; j <= N; j += i){
            d[j] += 1;
            s[j] += i;
        }
    }

    vector<int> prefD(N+1);
    vector<int> prefS(N+1);
    prefD[0] = 0;
    prefS[0] = 0;
    for(int i = 1; i <= N; ++i){
        prefD[i] = prefD[i-1] + d[i];
        prefS[i] = prefS[i-1] + s[i];
    }

    for(int i = 0; i < T; ++i){
        int l = L[i], r = R[i];
        int u = prefD[r] - prefD[l-1];
        int v = prefS[r] - prefS[l-1];
        cout << u << " " << v << endl;
    }
    return 0;
}
```
</details>

# **Bài 3: Nguyên tố tương đương**

<details>
<summary>Code mẫu</summary>

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5;
int spf[N], mx[N];

void sieve() {
    for (int i = 2; i < N; i++) {
        if (!spf[i]) {
            for (int j = i; j < N; j += i) {
                if (!spf[j]) spf[j] = i;
            }
        }
    }
}

void solve() {
    int n;
    cin >> n;
    vector<int> seen;
    long long ans = 0;

    for (int i = 0; i < n; i++) {
        int x; cin >> x;
        while (x > 1) {
            int p = spf[x] ? spf[x] : x;
            int c = 0;
            while (x % p == 0) {
                x /= p;
                c++;
            }
            if (mx[p] == 0) seen.push_back(p);
            mx[p] = max(mx[p], c);
        }
    }

    for (int p : seen) {
        ans += mx[p];
        mx[p] = 0;
    }

    cout << ans << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    sieve();

    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
</details>

# **Bài 4: Đếm số nghiệm**

Bất đẳng thức $x^d + y^d + z^d \equiv m \pmod n$ thực chất phụ thuộc vào giá trị của $x, y, z \pmod n$.Vì $n$ rất nhỏ ($n \le 100$), trong khi $u$ rất lớn ($u \le 10^9$), ta nhận thấy rằng dãy số từ $0$ đến $u$ sẽ lặp lại các số dư khi chia cho $n$ nhiều lần.

- Đếm tần suất số dư: Xác định xem trong đoạn $[0, u]$ có bao nhiêu số chia cho $n$ dư $0, 1, ..., n-1$.
    - Số lượng chu kỳ đầy đủ là $k = \lfloor \frac{u+1}{n} \rfloor$. Mỗi số dư từ $0$ đến $n-1$ sẽ xuất hiện ít nhất $k$ lần.
    - Phần dư lẻ ra là $r = (u+1) \pmod n$. Các số dư từ $0$ đến $r-1$ sẽ xuất hiện thêm 1 lần nữa.
- Nhóm theo giá trị mũ: Thay vì quan tâm số dư của $x$, ta quan tâm giá trị $v = x^d \pmod n$. Ta tính mảng cộng: Số lượng các số $x \in [0, u]$ sao cho $x^d \equiv v \pmod n$.
- Duyệt và tính tổng: Ta cần tìm số bộ ba $(a, b, c)$ là các giá trị sau khi lũy thừa, sao cho $(a + b + c) \equiv m \pmod n$.Ta dùng 2 vòng lặp để chọn $a$ và $b$ (từ $0$ đến $n-1$).Giá trị $c$ được xác định duy nhất: $c = (m - a - b) \pmod n$.Số lượng nghiệm đóng góp là tích của 3 cách chọn biến.

<details>
<summary>Code mẫu</summary>

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MOD = 1e9 + 7;
int powmod(int a, int e, int mod){
    if(mod == 1) return 0;
    int res = 1 % mod;
    a %= mod;
    while(e){
        if(e & 1) res = (res * a) % mod;
        a = (a * a) % mod;
        e >>= 1;
    }
    return res;
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    int T;
    cin >> T;
    while(T--){
        int u,d,m,n;
        cin >> u >> d >> m >> n;
        vector<int> freq(n,0);
        for(int a = 0; a < n; a++){
            if(a > u) continue;
            int cnt = (u - a) / n + 1;
            int p = powmod(a, d, n);
            freq[p] = (freq[p] + (cnt % MOD)) % MOD;
        }
        int ans = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                int rem = (m - (i + j) % n) % n;
                if(rem < 0) rem += n;
                int add = freq[i] * freq[j] % MOD;
                add = add * freq[rem] % MOD;
                ans += add;
                if(ans >= MOD) ans -= MOD;
            }
        }
        cout << ans % MOD << '\n';
    }
    return 0;
}
```
</details>

# **Bài 5: Tổng GCD**

<details>
<summary>Code mẫu</summary>

```cpp

```
</details>

# **Bài 6: Cột dây**

<details>
<summary>Code mẫu</summary>

```cpp

```
</details>
