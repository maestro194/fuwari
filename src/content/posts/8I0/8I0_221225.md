---
title: 8I0 - 22-12-2025
published: 2025-12-22
description: Hướng dẫn giải bài tập cho 8I0 - 22-12-2025
tags: [Editorial]
category: 8I0
draft: false
---

# **Bài 1: Tổng bộ ba**

Ta có thể biến đổi biểu thứ ban đầu của bài toán thành 

$$
a_i + a_j = a_x - a_k
$$

với $1 \le i < j < k < x \le n$

Từ đó ta có thể thực hiện phép đếm như sau:
- Với mỗi vị trí thứ $k (3 \le k \le N)$, ta ghép ```a[k]``` với một số nguyên ```a[x]``` $(k < x \le n)$
- Với mảng ```cnt[a[i] + a[j]]``` đếm số cặp $(i, j)$ thỏa mãn có tổng bằng $a_i + a_j (1 \le i < j < k)$, dựa vào biểu thức kết quả đã được biến đổi ở trên,
số cặp thỏa mãn với $a_x$ là ```cnt[a[x] - a[k]]```
- Sau khi đã xử lý xong ở vị trí thứ k, ta ghép $a_k$ với lần lượt các phần tử phía trước nó, cập nhật mảng ```cnt```

<details>
<summary>Code mẫu</summary>

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1e7 + 5;
const int base = 1e6; // chống index âm
ll a[100005], ans[100005];
int cnt[N];

int main() {
    int n; cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }    
    cnt[a[1] + a[2] + base * 2] = 1;
    
    for (int k = 3; k <= n; i++) {

        for (int x = i + 1; x <= n; j++) {
            ans[x] += cnt[a[x] - a[k] + base * 2];
        }

        for (int j = i - 1; j >= 1; j--) cnt[a[i] + base + a[j] + base]++;
    } 
    for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
}
```
</details>

# **Bài 2: Bitwise ops**

<details>
<summary>Code mẫu</summary>

```cpp
#include <bits/stdc++.h>
#pragma GCC optimization ("Ofast")
using namespace std;

void solve() {
    int n;
    long long k;
    if (!(cin >> n >> k)) return;

    vector<long long> p1(n), p2(n), p3(n), p4(n);
    for (int i = 0; i < n; ++i) cin >> p1[i];
    for (int i = 0; i < n; ++i) cin >> p2[i];
    for (int i = 0; i < n; ++i) cin >> p3[i];
    for (int i = 0; i < n; ++i) cin >> p4[i];

    vector<long long> v1;
    v1.reserve(n * n);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            v1.push_back(p1[i] ^ p2[j]);
        }
    }

    sort(v1.begin(), v1.end());
    long long ans = 0;

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            long long target = k ^ p3[i] ^ p4[j];
            auto range = equal_range(v1.begin(), v1.end(), target);
            ans += distance(range.first, range.second);
        }
    }
    cout << ans << endl;
}

int main() {
    ios_base::sync_with_stdio(false);cin.tie(NULL);
    solve();
    return 0;
}
```
</details>

# **Bài 3: Khu rừng 1**

Bài yêu cầu tìm một hình vuông kích thước $k * k$ có tổng lớn nhất.

Với một tọa độ $(i, j)$ với $k \le i, j \le n$, ta có thể sử dụng Prefix Sum 2D để tính được tổng của hình vuông trong độ phức tạp là $O(1)$

```
sum = PFS[i][j] - PFS[i - k][j] - PFS[i][j - k] + PFS[i - k][j - k];
```

Kết quả của bài toán là max của các giá trị ```sum``` ở trên

<details>
<summary>Code mẫu</summary>

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k;
long long a[1001][1001], PFS[1001][1001];
int main() {
    cin >> m >> n >> k;
    for(int i = 1; i <= m; i ++) for(int j = 1; j <= n; j ++) {
        cin >> a[i][j];
        PFS[i][j] = PFS[i][j - 1] + PFS[i - 1][j] - PFS[i][j] + a[i][j];
    }
    long long ans = -LLONG_MAX;
    for(int i = k; i <= m; i ++) for(int j = k; j <= n; j ++) {
        ans = max(ans, PFS[i][j] - PFS[i - k][j] - PFS[i][j - k] + PFS[i - k][j - k]);
    }
    cout << ans;
}
```
</details>

# **Bài 4: Khu rừng 2**

Ý tưởng tương tự với Khu rừng 1, nhưng ta sẽ sử dụng mảng hiệu để xử lý

<details>
<summary>Code mẫu</summary>

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, k;
long long a[1001][1001];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> k;
    for(int i = 0; i < k; i++) {
        int x, y, u, v; long long w;
    	cin >> x >> y >> u >> v >> w;
    	for(int j = x - 1; j < u; j++) {
    		a[j][y - 1] += w;
    		a[j][v] -= w;
    	}
    }
    for(int i = 0; i < n; i++) {
    	ll cur = 0;
    	for(int j = 0; j < m; j++) {
    		cur += a[i][j];
    		cout << cur + 1 << " ";
    	}
    	cout << endl;
    }
}
```
</details>

# **Bài 5: Astronomical Sign**

Một bài switch case đơn giản, chỉ yêu cầu xét hết các trường hợp và in ra các kí tự đúng chính tả để có thể hoàn thành trong 1 lần nộp

<details>
<summary>Code mẫu</summary>

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    cin >> t;
    while(t--) {
    	cin >> m >> s;
    	if((s == "Mar" && m >= 21) || (s == "Apr" && m <= 20)) cout << "Aries" << endl;
    	else if((s == "Apr" && m >= 21) || (s == "May" && m <= 20)) cout << "Taurus" << endl;
    	else if((s == "May" && m >= 21) || (s == "Jun" && m <= 21)) cout << "Gemini" << endl;
    	else if((s == "Jun" && m >= 22) || (s == "Jul" && m <= 22)) cout << "Cancer" << endl;
    	else if((s == "Jul" && m >= 23) || (s == "Aug" && m <= 22)) cout << "Leo" << endl;
    	else if((s == "Aug" && m >= 23) || (s == "Sep" && m <= 21)) cout << "Virgo" << endl;
    	else if((s == "Sep" && m >= 22) || (s == "Oct" && m <= 22)) cout << "Libra" << endl;
    	else if((s == "Oct" && m >= 23) || (s == "Nov" && m <= 22)) cout << "Scorpio" << endl;
    	else if((s == "Nov" && m >= 23) || (s == "Dec" && m <= 21)) cout << "Sagittarius" << endl;
    	else if((s == "Dec" && m >= 22) || (s == "Jan" && m <= 20)) cout << "Capricorn" << endl;
    	else if((s == "Jan" && m >= 21) || (s == "Feb" && m <= 19)) cout << "Aquarius" << endl;
    	else if((s == "Feb" && m >= 20) || (s == "Mar" && m <= 20)) cout << "Pisces" << endl;
    }
}
```
</details>

# **Bài 6: Angry Birbs**

Phương trình đề bài cho là một parabol (với $c \ne 0$) hoặc một đường thẳng (với $c = 0$)

Vì thế ta chỉ cần kiểm tra $c$ để biết được hướng bay của chim là hướng nào

<details>
<summary>Code mẫu</summary>

```cpp
#include <bits/>stdc++.h>
using namespace std;

int a, b, c;
int main() {
    int t; cin >> t;
    while(t--) {
    	cin >> a >> b >> c;
    	if(c == 0) cout << "NO CURVE" << endl;
    	else if(c > 0) cout << "CURVE UP" << endl;
    	else cout << "CURVE DOWN" << endl;
    }
}
```
</details>
