---
title: 8I0 - 03-11-2025 - Không có gì ngoài quy hoạch động
published: 2025-11-03
description: Hướng dẫn giải bài tập cho 8I0 - 03-11-2025
tags: [Editorial]
category: 8I0
draft: false
---

# **Bài 1: Xâu con chung dài nhất**

## 1. Ý tưởng
Gọi ``dp[i][j]`` là độ dài của xâu con chung dài nhất giữa 2 xâu ``a[0...i]``, ``b[0...j]``

Ta có nhận xét với 2 kí tự ``a[i]`` và ``b[j]`` của 2 xâu như sau:
- Nếu ``a[i] = b[j]``, ta có thể tạo được một xâu con chung từ xâu con chung tính đến ``a[0..i-1]`` và ``b[0..j-1]``, thêm với 
kí tự a[i]/b[j]

```cpp
dp[i][j] = dp[i-1][j-1] + 1;
```
- Nếu ``a[i] != b[i]``, ta có thể bỏ qua kí tự này và tiến đến kí tự tiếp theo mà không gây ảnh hưởng đến độ dài xâu con chung dài nhất

```cpp
dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
```

Về khởi tạo, ta có thể xác định được là:
``dp[i][0] = dp[0][j] = 0`` với mọi i, j <= |X|,|Y|

Kết quả của bài toán là giá trị của ``dp[|X|][|Y|]``

## 2. Phân tích độ phức tạp
Với lần lượt các kí tự của xâu |X|, ta kiểm tra tính chất trên với các kí tự của xâu |Y|.

Độ phức tạp: $O(|X||Y|)$

## 3. Mã nguồn
```cpp
cin >> x >> y;
n = x.size();
m = y.size();
x = " " + x; // thêm dấu " " để xử lý với index từ 1..n
y = " " + y;

FOR(i, 1, n) dp[i][0] = 0;
FOR(j, 1, m) dp[0][j] = 0;

FOR(i, 1, n) FOR(j, 1, m)
if (x[i] == y[j])
    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1);
else
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);

vector<char> z;
ll i = n,j = m;
while(i > 0 && j > 0) {
    if(x[i] == y[j]){
        z.push_back(x[i]);
        i--;
        j--;
    } else if(dp[i-1][j]>dp[i][j-1]) i--;
    else j--;
}
reverse(z.begin(),z.end());
for(auto c : z) cout << c;1..n
```

# **Bài 2: Subsetsum**

## 1. Ý tưởng
Đầu tiên, ta có thể giới hạn ``m`` qua nhận xét: Nếu tổng các phần từ trong mảng ``a`` mà bé hơn `m`, ta không tìm được cách cộng -> giảm độ phức tạp của tổng m xuống `100 * 1000 = 100000`

`dp[s] = i` nghĩa là có thể đạt tổng `s` bằng cách chọn phần tử `a[i]` cuối cùng.  

Khởi tạo `dp[0] = 0` (tổng 0 có thể đạt được mà không chọn phần tử nào).  

Duyệt qua từng phần tử, cập nhật `dp` từ lớn xuống nhỏ để tránh dùng lại phần tử nhiều lần.

Sau khi duyệt, nếu `dp[m]` có giá trị hợp lệ, thì ta truy vết ngược lại để tìm các chỉ số.

## 2. Độ phức tạp
- Thời gian: ~\( O(n \times \text{sumA}) \)~
- Bộ nhớ: ~~\( O(\text{sumA}) \)~

## 3. Mã nguồn
```cpp
int maxSum = accumulate(a.begin(), a.end(), 0);
vector<int> dp(maxSum + 1, -1);
dp[0] = 0;

for (int i = 1; i <= n; i++) {
    for (int s = maxSum; s >= a[i]; s--) {
        if (dp[s - a[i]] != -1 && dp[s] == -1)
            dp[s] = i; 
    // ở đây ta lưu luôn truy vết, sử dụng a[dp[s]] có thể tạo 
    // được tổng qua s - a[dp[s]]
    }
}

// kiểm tra tổng 
if (m > maxSum || dp[m] == -1) {
    cout << "NO\n";
    return 0;
}

cout << "YES\n";
vector<int> chosen;
int sum = m;
while (sum > 0) {
    int i = dp[sum];
    chosen.push_back(i);
    sum -= a[i];
}
sort(chosen.begin(), chosen.end());
for (int i = 0; i < (int)chosen.size(); i++) {
    if (i) cout << " ";
    cout << chosen[i];
}
```


# **Bài 3: Kéo co**

## 1. Ý tưởng
- Tổng trọng lượng: `sum = Σ a[i]`
- Mục tiêu: chọn tập con có tổng gần nhất với `sum / 2`
- Nếu chọn tập con có tổng `S`, thì chênh lệch = `|sum - 2*S|`
- Ta cần tìm `S` nhỏ nhất sao cho chênh lệch nhỏ nhất.

Dựa trên nhận xét trên, ta có thể thực hiện thuật toán quy hoạch động như sau
- Dùng quy hoạch động để xác định những tổng có thể tạo ra.
   - `dp[i][s] = true` nếu có thể đạt tổng `s` khi xét đến `i` phần tử đầu tiên.
   - Cách xử lý giống với bài 2, không hiểu quay lên đọc lại :/
- Sau khi xử lý quy hoạch động, ta có thể lần lượt tính các tổng với
- Khi tìm được tổng `S` gần nhất với `sum/2`, ta truy vết ngược lại để biết những phần tử nào thuộc nhóm 1.

## 2. Phân tích độ phức tạp
- Giới hạn: `sum(a_i) ≤ 1,000,000`, khả thi với `n ≤ 100`.
- Độ phức tạp: ~O(n * S / 2)~

## 3. Mã nguồn
```cpp
int n;
cin >> n;
vector<int> a(n + 1);
int total = 0;
for (int i = 1; i <= n; i++) {
    cin >> a[i];
    total += a[i];
}

int target = total / 2;
vector<vector<bool>> dp(n + 1, vector<bool>(target + 1, false));
vector<vector<bool>> take(n + 1, vector<bool>(target + 1, false));

dp[0][0] = true;

for (int i = 1; i <= n; i++) {
    for (int s = 0; s <= target; s++) {
        dp[i][s] = dp[i - 1][s];
        if (s >= a[i] && dp[i - 1][s - a[i]]) {
            dp[i][s] = true;
            take[i][s] = true;
        }
    }
}

int best = 0;
for (int s = target; s >= 0; s--) {
    if (dp[n][s]) {
        best = s;
        break;
    }
}

// Truy vết để tìm nhóm I
vector<int> group1, group2;
int s = best;
for (int i = n; i >= 1; i--) {
    if (take[i][s]) {
        group1.push_back(i);
        s -= a[i];
    } else {
        group2.push_back(i);
    }
}

reverse(group1.begin(), group1.end());
reverse(group2.begin(), group2.end());

cout << group1.size() << " " << group2.size() << "\n";
for (int i = 0; i < (int)group1.size(); i++) {
    if (i) cout << " ";
    cout << group1[i];
}
cout << "\n";
for (int i = 0; i < (int)group2.size(); i++) {
    if (i) cout << " ";
    cout << group2[i];
}
```

# **Bài 4: Biến đổi xâu**

## 1. Ý tưởng
### Ký hiệu:
- `dp[i][0]`: số phép biến đổi nhỏ nhất để biến **xâu con S[0..i]** thành toàn `A` **và** ký tự `s_i` hiện đang là `A`.
- `dp[i][1]`: số phép biến đổi nhỏ nhất để biến **xâu con S[0..i]** thành toàn `A` **và** ký tự `s_i` hiện đang là `B`.

### Trạng thái gốc
- Nếu `S[0] == 'A'`:  
  `dp[0][0] = 0`, `dp[0][1] = 1` (phải đổi ký tự đầu sang `B`)
- Nếu `S[0] == 'B'`:  
  `dp[0][0] = 1`, `dp[0][1] = 0`

### Chuyển trạng thái
Với mỗi vị trí `i > 0`:
- Nếu muốn kết thúc tại `A` (`dp[i][0]`):
  - Giữ nguyên ký tự `A` từ trước (`dp[i-1][0]`), có thể cần `P(i)` nếu `s[i] == 'B'`
  - Hoặc lật toàn bộ chuỗi trước (`Q(i)`), khiến trạng thái đảo chiều từ `B` sang `A`
  
  ⇒ `dp[i][0] = min(dp[i-1][0] + cost_P, dp[i-1][1] + 1)`

- Nếu muốn kết thúc tại `B` (`dp[i][1]`):
  - Giữ nguyên `B` từ trước (`dp[i-1][1]`), có thể cần `P(i)` nếu `s[i] == 'A'`
  - Hoặc lật toàn bộ chuỗi trước (`Q(i)`), khiến trạng thái đảo chiều từ `A` sang `B`
  
  ⇒ `dp[i][1] = min(dp[i-1][1] + cost_P, dp[i-1][0] + 1)`

Trong đó `cost_P = 1` nếu ký tự cần đổi (`s[i]` khác ký tự mong muốn), ngược lại `cost_P = 0`.

Kết quả của bài toán là `dp[n-1][0]`, do ta cần chuyển tất cả các ký tự về `A`

## 2. Phân tích độ phức tạp
- Quy hoạch động duyệt qua từng kí tự của xâu S: `O(N)`

## 3. Mã nguồn
```cpp
string s;
cin >> s;
int n = s.size();

vector<vector<int>> dp(n, vector<int>(2, 0));

// Khởi tạo
dp[0][0] = (s[0] == 'A' ? 0 : 1);
dp[0][1] = (s[0] == 'B' ? 0 : 1);

// Quy hoạch động
for (int i = 1; i < n; i++) {
    int costA = (s[i] == 'A' ? 0 : 1);
    int costB = (s[i] == 'B' ? 0 : 1);

    dp[i][0] = min(dp[i - 1][0] + costA, dp[i - 1][1] + 1);
    dp[i][1] = min(dp[i - 1][1] + costB, dp[i - 1][0] + 1);
}

cout << dp[n - 1][0] << "\n";
```

# **Bài 5: Mô hình**

## 1. Ý tưởng
Ta nhận thấy rằng mỗi viên gạch có hai trạng thái:
- Đặt theo chiều gốc (`a_i` làm chiều cao)
- Xoay (`b_i` làm chiều cao)

Đặt `dp[i][0]`, `dp[i][1]` lần lượt là **độ dài đường đi lớn nhất** đến viên thứ `i`,  
với:
- `dp[i][0]`: gạch `i` **không xoay**
- `dp[i][1]`: gạch `i` **xoay**

### Trạng thái ban đầu
- `dp[1][0] = b[i]` 
- `dp[1][1] = a[i]`

### Chuyển trạng thái
Với mọi `i > 1`:

```cpp
dp[i][0] = max(
    dp[i-1][0] + abs(a[i] - a[i-1]) + b[i], // i-1 không xoay
    dp[i-1][1] + abs(a[i] - b[i-1]) + b[i] // i-1 xoay
)

dp[i][1] = max(
    dp[i-1][0] + abs(b[i] - a[i-1]) + a[i],
    dp[i-1][1] + abs(b[i] - b[i-1]) + a[i]
)
```

## 2. Phân tích độ phức tạp
Duyệt qua `2*N` trạng thái của `N` viên gạch

## 3. Mã nguồn
```cpp
int n;
cin >> n;
vector<ll> a(n + 1), b(n + 1);
for (int i = 1; i <= n; i++) cin >> a[i] >> b[i];

vector<vector<ll>> dp(n + 1, vector<ll>(2, 0));

// Base case
dp[1][0] = a[1] + b[1];
dp[1][1] = b[1] + a[1];

for (int i = 2; i <= n; i++) {
    dp[i][0] = max(
        dp[i-1][0] + abs(a[i] - a[i-1]) + b[i],
        dp[i-1][1] + abs(a[i] - b[i-1]) + b[i]
    );
    dp[i][1] = max(
        dp[i-1][0] + abs(b[i] - a[i-1]) + a[i],
        dp[i-1][1] + abs(b[i] - b[i-1]) + a[i]
    );
}

cout << max(dp[n][0], dp[n][1]) << "\n";
```

# **Bài 6: Herta112 - Taro's Happiness Function**

## 1. Ý tưởng
Với mỗi ngày, ta có thể chọn làm 1 trong 3 hành động.

Gọi `dp[i][j]` là tổng độ vui vẻ của Taro sau khi làm xong việc `j` vào ngày `i`.

### Trạng thái gốc
Vì ngày 1, ta không có ràng buộc gì về công việc mà Taro có thể chọn, ta có:
```cpp
dp[1][0] = a[i];
dp[1][1] = b[i];
dp[1][2] = c[i];
```

Với mỗi ngày từ ngày thứ 2, ta không thể có 2 ngày liên tiếp làm cùng một hành động, vì thế nếu ta chọn làm hành động `a` vào ngày `i`, ta phải tính nó từ các trường hợp không làm hành động `a` trong ngày `i-1` trước đó

```cpp
dp[i][0] = a[i] + max(dp[i - 1][1], dp[i - 1][2]);
```

Áp dụng logic trên với 2 công việc còn lại

## 2. Phân tích độ phức tạp
Ta duyệt qua `3 * N` các công việc của Taro có thể chọn trong `N` ngày, độ phức tạp ~O(N)~

## 3. Mã nguồn (tự nghĩ 1 chút xem)
```cpp

```

# **Bài 7: Herta111 - Đếm đường đi trong mê cung lưới**

## 1. Ý tưởng


## 2. Phân tích độ phức tạp

## 3. Mã nguồn
```cpp
```

# **Bài 8: Herta110 - Chia kẹo**

## 1. Ý tưởng

## 2. Phân tích độ phức tạp

## 3. Mã nguồn
```cpp
cin >> n >> k;
for(int i = 1; i <= n; i++) cin >> a[i];

pre[0] = 1;
for(int i = 1; i <= n; i ++) {
    // chuẩn bị pfs
    for(int i = 1; i <= k; i ++) pre[i] = (pre[i] + pre[i - 1]) % mod;
    // số cách ghép được tổng bằng j có thể đạt được bằng tổng số cách
    // từ các vị trí từ j - a[i] tới j (cho trẻ i từ 0 đến a[i] kẹo)
    for(int j = a[i]; j <= k; j ++) 
        dp[j] = (pre[j] - pre[j - a[i] - 1] + mod) % mod;
    // chuyển tới trẻ tiếp theo
    swap(pre, dp);
}
// kết quả là số cách chia k kẹo
cout << pre[k];
```

