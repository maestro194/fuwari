---
title: 8I0 - 06-10-2025
published: 2025-10-06
description: Hướng dẫn giải bài tập 8I0 - 06-10-2025
tags: [Editorial]
category: 8I0
draft: false
---

# **Bài 1: Con thuyền nguyên tố**

## 1. Ý tưởng

Bài cho một ma trận kích thước \( N \times M \), mỗi ô chứa chữ số (0–9).  
Ta cần tìm **mọi số nguyên tố có ≤ 6 chữ số** được tạo ra bằng cách đọc liên tiếp theo **3 hướng**:
- ngang phải (→)
- dọc xuống (↓)
- chéo xuống phải (↘)

Mỗi số có thể có độ dài từ 1 → 6 chữ số.  
Nếu một số xuất hiện ở nhiều vị trí khác nhau, ta **tính mỗi lần một lần riêng biệt**.

Ta cần in:
- Số lượng số nguyên tố tìm được
- Tổng giá trị của tất cả số nguyên tố đó

---

## 2. Chứng minh tính đúng đắn

- Với mỗi ô làm **ô bắt đầu**, ta có thể sinh các chuỗi con theo 3 hướng.  
  Mỗi chuỗi con dài ≤ 6 ký tự, vì vậy mỗi ô sinh tối đa $3 \times 6 = 18$ số.  
- Tổng số ô: $N x M$, nên tổng số số được tạo ra ≤ $18 \times N \times M$.

Với $N, M \le 1500$:  
→ tối đa $18 \times 2.25 \times 10^6 ≈ 4 \times 10^7$ số.  
Tuy nhiên, ta **có thể cắt sớm** nếu đi quá biên.  
Và việc kiểm tra nguyên tố ≤ 10⁶ là cực nhanh bằng sieve.

Do đó giải pháp hoàn toàn trong giới hạn thời gian.

---

## 3. Độ phức tạp

- Sàng nguyên tố: $O(10^6 \log\log 10^6)$
- Duyệt ma trận: $O(NM)$
- Với mỗi ô, tạo ≤ 18 số → $O(18NM)$

Tổng thể: **$O(NM)$**, rất hiệu quả.


### Mã nguồn: 

```cpp
int N, M;
cin >> N >> M;
vector<vector<int>> a(N, vector<int>(M));
for (int i = 0; i < N; i++)
    for (int j = 0; j < M; j++)
        cin >> a[i][j];

const int LIMIT = 999999;
vector<bool> prime(LIMIT + 1, true);
prime[0] = prime[1] = false;
for (int i = 2; i * i <= LIMIT; i++)
    if (prime[i])
        for (int j = i * i; j <= LIMIT; j += i)
            prime[j] = false;

int dx[3] = {1, 0, 1};
int dy[3] = {0, 1, 1};

long long cnt = 0, sum = 0;
for (int i = 0; i < N; i++) {
    for (int j = 0; j < M; j++) {
        if (a[i][j] == 0)
            continue;
        if (a[i][j] <= LIMIT && prime[a[i][j]]) {
            cnt ++;
            sum += a[i][j];
        }
        for (int d = 0; d < 3; d++) {
            int x = i, y = j;
            int val = a[x][y];
            for (int len = 0; len < 6; len++) {
                x += dx[d];
                y += dy[d];
                if (x < 0 || x >= N || y < 0 || y >= M) break;
                val = val * 10 + a[x][y];
                if (val <= LIMIT && prime[val]) {
                    cnt++;
                    sum += val;
                }
            }
        }
    }
}

cout << cnt << " " << sum << "\n";
```

# **Bài 2: Mã số ống đồng**

## 1. Ý tưởng

Bài toán yêu cầu tìm **số đối xứng nhỏ nhất lớn hơn N**, với N có thể dài đến 10⁶ chữ số, do đó không thể xử lý bằng kiểu số nguyên thông thường — ta phải thao tác trực tiếp trên chuỗi.

Số đối xứng (palindrome) là số mà đọc từ trái sang phải giống từ phải sang trái.  
Ví dụ: 121, 999, 1221, 54345.

Ta cần tìm số palindrome nhỏ nhất > N.

---

## 2. Cách tiếp cận

### a. Phân tích cấu trúc số palindrome

Gọi:
- `L` = độ dài của N
- `left` = nửa đầu của N (với phần giữa tính tùy theo chẵn/lẻ)

Nếu ta **phản chiếu nửa đầu sang phải**, ta thu được một số palindrome.

Ví dụ:
- N = `1234` → `left = 12` → mirror → `1221`
- N = `12932` → `left = 129` → mirror → `12921`

Sau khi tạo palindrome này:
- Nếu palindrome ≤ N → ta cần **tăng phần “nửa đầu” lên 1**, rồi phản chiếu lại.
- Nếu palindrome > N → đó là đáp án.

### b. Xử lý trường hợp đặc biệt

- Nếu tất cả các chữ số là `9` (vd: 9, 99, 999, 9999) → kết quả là `100...001`.
  Ví dụ:
  - 9 → 11
  - 99 → 101
  - 999 → 1001

---

## 3. Tính đúng đắn

- Thuật toán luôn sinh ra số đối xứng bằng cách phản chiếu, do đó kết quả chắc chắn là palindrome.
- So sánh với N đảm bảo tính “nhỏ nhất lớn hơn N”.
- Việc tăng phần `left` đảm bảo không bỏ sót trường hợp “chuyển sang mức hàng mới” (vd: 999 → 1001).

---

## 4. Độ phức tạp

- Tạo palindrome và so sánh: $O(L)$
- Thao tác trên chuỗi có độ dài ≤ 10⁶: $O(L)$

Tổng thể: **$O(L)$**, đủ nhanh cho giới hạn bài toán.

---

## 5. Cài đặt mẫu (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

string add_one(string s) {
    int i = s.size() - 1;
    while (i >= 0 && s[i] == '9') {
        s[i] = '0';
        i--;
    }
    if (i < 0) s = '1' + s;
    else s[i]++;
    return s;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string n;
    cin >> n;
    int len = n.size();

    bool all9 = true;
    for (char c : n) if (c != '9') all9 = false;
    if (all9) {
        cout << '1';
        for (int i = 0; i < len - 1; i++) cout << '0';
        cout << '1';
        return 0;
    }

    string left = n.substr(0, (len + 1) / 2);
    string palin = left;
    string rev = left.substr(0, len / 2);
    reverse(rev.begin(), rev.end());
    palin += rev;

    if (palin <= n) {
        left = add_one(left);
        palin = left;
        rev = left.substr(0, len / 2);
        reverse(rev.begin(), rev.end());
        palin += rev;
    }

    cout << palin;
}
```

# **Bài 3: Ném bom**



# **Bài 4: Thùng hàng**
# **Bài 5: Hình chữ nhật gần nhất**

