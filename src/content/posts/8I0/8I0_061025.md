---
title: 8I0 - 06-10-2025
published: 2025-10-06
description: Hướng dẫn giải bài tập cho 8I0 - 06-10-2025
tags: [Editorial]
category: 8I0
draft: false
---

# **Bài 1: Con thuyền nguyên tố**

## 1. Ý tưởng

Bài cho một ma trận kích thước \( N \times M \), mỗi ô chứa chữ số (0–9).  
Ta cần tìm **mọi số nguyên tố có ≤ 6 chữ số** được tạo ra bằng cách đọc liên tiếp theo **3 hướng**:
- ngang phải (→)
- dọc xuống (↓)
- chéo xuống phải (↘)

Mỗi số có thể có độ dài từ 1 → 6 chữ số.  
Nếu một số xuất hiện ở nhiều vị trí khác nhau, ta **tính mỗi lần một lần riêng biệt**.

Ta cần in:
- Số lượng số nguyên tố tìm được
- Tổng giá trị của tất cả số nguyên tố đó

## 2. Chứng minh tính đúng đắn

- Với mỗi ô làm **ô bắt đầu**, ta có thể sinh các chuỗi con theo 3 hướng.  
  Mỗi chuỗi con dài ≤ 6 ký tự, vì vậy mỗi ô sinh tối đa $3 \times 6 = 18$ số.  
- Tổng số ô: $N \times M$, nên tổng số số được tạo ra ≤ $18 \times N \times M$.

Với $N, M \le 1500$:  
→ tối đa $18 \times 2.25 \times 10^6 ≈ 4 \times 10^7$ số.  
Tuy nhiên, ta **có thể cắt sớm** nếu đi quá biên.  
Và việc kiểm tra nguyên tố ≤ 10⁶ là cực nhanh bằng sieve.

Do đó giải pháp hoàn toàn trong giới hạn thời gian.

## 3. Độ phức tạp

- Sàng nguyên tố: $O(10^6 \log\log 10^6)$
- Duyệt ma trận: $O(NM)$
- Với mỗi ô, tạo ≤ 18 số → $O(18NM)$

Tổng thể: **$O(NM)$**, rất hiệu quả.


## 4. Mã nguồn: 

```cpp
int N, M;
cin >> N >> M;
vector<vector<int>> a(N, vector<int>(M));
for (int i = 0; i < N; i++)
    for (int j = 0; j < M; j++)
        cin >> a[i][j];

const int LIMIT = 999999;
vector<bool> prime(LIMIT + 1, true);
prime[0] = prime[1] = false;
for (int i = 2; i * i <= LIMIT; i++)
    if (prime[i])
        for (int j = i * i; j <= LIMIT; j += i)
            prime[j] = false;

int dx[3] = {1, 0, 1};
int dy[3] = {0, 1, 1};

long long cnt = 0, sum = 0;
for (int i = 0; i < N; i++) {
    for (int j = 0; j < M; j++) {
        if (a[i][j] == 0)
            continue;
        if (a[i][j] <= LIMIT && prime[a[i][j]]) {
            cnt ++;
            sum += a[i][j];
        }
        for (int d = 0; d < 3; d++) {
            int x = i, y = j;
            int val = a[x][y];
            for (int len = 0; len < 6; len++) {
                x += dx[d];
                y += dy[d];
                if (x < 0 || x >= N || y < 0 || y >= M) break;
                val = val * 10 + a[x][y];
                if (val <= LIMIT && prime[val]) {
                    cnt++;
                    sum += val;
                }
            }
        }
    }
}

cout << cnt << " " << sum << "\n";
```

# **Bài 2: Mã số ống đồng**

## 1. Ý tưởng

Bài toán yêu cầu tìm **số đối xứng nhỏ nhất lớn hơn N**, với N có thể dài đến 10⁶ chữ số, do đó không thể xử lý bằng kiểu số nguyên thông thường — ta phải thao tác trực tiếp trên chuỗi.

Số đối xứng (palindrome) là số mà đọc từ trái sang phải giống từ phải sang trái.  
Ví dụ: 121, 999, 1221, 54345.

Ta cần tìm số palindrome nhỏ nhất > N.

## 2. Cách tiếp cận

### a. Phân tích cấu trúc số palindrome

Gọi:
- `L` = độ dài của N
- `left` = nửa đầu của N (với phần giữa tính tùy theo chẵn/lẻ)

Nếu ta **phản chiếu nửa đầu sang phải**, ta thu được một số palindrome.

Ví dụ:
- N = `1234` → `left = 12` → mirror → `1221`
- N = `12932` → `left = 129` → mirror → `12921`

Sau khi tạo palindrome này:
- Nếu palindrome ≤ N → ta cần **tăng phần “nửa đầu” lên 1**, rồi phản chiếu lại.
- Nếu palindrome > N → đó là đáp án.

### b. Xử lý trường hợp đặc biệt

- Nếu tất cả các chữ số là `9` (vd: 9, 99, 999, 9999) → kết quả là `100...001`.
  Ví dụ:
  - 9 → 11
  - 99 → 101
  - 999 → 1001

## 3. Tính đúng đắn

- Thuật toán luôn sinh ra số đối xứng bằng cách phản chiếu, do đó kết quả chắc chắn là palindrome.
- So sánh với N đảm bảo tính “nhỏ nhất lớn hơn N”.
- Việc tăng phần `left` đảm bảo không bỏ sót trường hợp “chuyển sang mức hàng mới” (vd: 999 → 1001).

## 4. Độ phức tạp

- Tạo palindrome và so sánh: $O(L)$
- Thao tác trên chuỗi có độ dài ≤ 10⁶: $O(L)$

Tổng thể: **$O(L)$**, đủ nhanh cho giới hạn bài toán.

## 5. Mã nguồn

```cpp
#include <bits/stdc++.h>
using namespace std;

string add_one(string s) {
    int i = s.size() - 1;
    while (i >= 0 && s[i] == '9') {
        s[i] = '0';
        i--;
    }
    if (i < 0) s = '1' + s;
    else s[i]++;
    return s;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string n;
    cin >> n;
    int len = n.size();

    bool all9 = true;
    for (char c : n) if (c != '9') all9 = false;
    if (all9) {
        cout << '1';
        for (int i = 0; i < len - 1; i++) cout << '0';
        cout << '1';
        return 0;
    }

    string left = n.substr(0, (len + 1) / 2);
    string palin = left;
    string rev = left.substr(0, len / 2);
    reverse(rev.begin(), rev.end());
    palin += rev;

    if (palin <= n) {
        left = add_one(left);
        palin = left;
        rev = left.substr(0, len / 2);
        reverse(rev.begin(), rev.end());
        palin += rev;
    }

    cout << palin;
}
```

# **Bài 3: Ném bom**

## 1. Ý tưởng

Gọi bảng có kích thước $N \times M$, mỗi ô chứa giá trị $a_{i,j}$.

Một **quả bom** được ném vào ô tâm $(x_0, y_0)$ với **bán kính $k$** sẽ ảnh hưởng đến tất cả các ô $(x, y)$ thoả mãn:
$$
|x - x_0| + |y - y_0| < k
$$
— tức là toàn bộ các ô trong **hình thoi** bán kính \(k - 1\).

Giá trị $k$ **không cố định** — ta được phép chọn $k$ sao cho hình thoi này nằm **trọn trong bảng**.  
Điều kiện đó tương đương với:
$$
k \le \min(x_0,\, N - x_0 + 1,\, y_0,\, M - y_0 + 1)
$$

Bài toán yêu cầu tìm toạ độ tâm $(x_0, y_0)$ và bán kính $k$ sao cho tổng các giá trị trong hình thoi là **lớn nhất**.

Để tính tổng hình thoi nhanh, ta biến đổi hệ toạ độ:
$$
u = x + y, \quad v = x - y
$$
Trong hệ $(u, v)$, miền hình thoi trong $(x, y)$ trở thành **hình chữ nhật**:
$$
|x - x_0| + |y - y_0| < k \iff |u - u_0| < k,\ |v - v_0| < k
$$
với $u_0 = x_0 + y_0,\, v_0 = x_0 - y_0$.

Nhờ đó, ta có thể:
1. Dựng mảng mới `B[u][v]`, trong đó mỗi ô `(u,v)` chứa tổng giá trị tương ứng từ `(x,y)`.
2. Dựng mảng cộng dồn 2D trên `B`.
3. Với mỗi tâm $(x_0, y_0)$, ta thử mọi $k$ hợp lệ, và lấy tổng hình chữ nhật trong $(u,v)$ để ra tổng hình thoi.

## 2. Phân tích độ phức tạp

- Chuyển đổi toạ độ và xây dựng mảng `B[u][v]`: $O(NM)$
- Dựng prefix sum 2D trên `B`: $O((N+M)^2)$
- Duyệt qua mọi tâm $(x_0, y_0)$: $O(NM)$
- Với mỗi tâm, duyệt các bán kính $k$ khả dĩ: $O(\min(N,M))$

Tổng độ phức tạp:
$
O(NM \times \min(N, M))
$

Với $N, M \le 500$, thuật toán chạy hiệu quả trong thời gian giới hạn.

## 3. Mã nguồn
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m;
    cin >> n >> m;
    vector<vector<long long>> a(n+1, vector<long long>(m+1));
    for(int i=1;i<=n;i++) 
        for(int j=1;j<=m;j++) 
            cin>>a[i][j];
    int U = n + m + 5;
    int V = n + m + 5;
    vector<vector<long long>> B(U, vector<long long>(V,0));
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            int u = i + j;
            int v = i - j + m;
            B[u][v] += a[i][j];
        }
    }
    vector<vector<long long>> P(U, vector<long long>(V,0));
    for(int i=1;i<U;i++){
        long long row_sum = 0;
        for(int j=1;j<V;j++){
            row_sum += B[i][j];
            P[i][j] = P[i-1][j] + row_sum;
        }
    }
    long long best = LLONG_MIN;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            int K = min(min(i, n - i + 1), min(j, m - j + 1));
            int u0 = i + j;
            int v0 = i - j + m;
            for(int k=1;k<=K;k++){
                int u1 = u0 - (k-1), u2 = u0 + (k-1);
                int v1 = v0 - (k-1), v2 = v0 + (k-1);
                long long s = P[u2][v2] - P[u1-1][v2] - P[u2][v1-1] + P[u1-1][v1-1];
                if(s>best) best=s;
            }
        }
    }
    cout<<best;
    return 0;
}

```
<!-- 
# **Bài 4: Thùng hàng**
# **Bài 5: Hình chữ nhật gần nhất** -->

